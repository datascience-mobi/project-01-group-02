---
title: "Group 02 - Skin Cancer"
author: "Leonie Thomas, Isabel Potthof, Elif Tosun and Marlene Khin"
date: "21.07.2019"
output:
  word_document: default
  pdf_document: default
  html_document: default
---
#  <span style="color:orange">**Preparations**</span>

## 1.Loading following packages
```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(relaimpo)
library(factoextra)
library(gridExtra)
library(reshape2)
library(data.table)
library(cluster)
library(rstudioapi)
library(pheatmap)
library(caret)
library(tidyverse)
library(dendextend)
library(factoextra)
library(devtools)
library(ggfortify)
library(rstudioapi)  
library(data.table) 
library(ggplot2) 
library(scales) 
library(stats)
library(caTools)  
```

## 2. Setting the sys-path and loading the data
The sys-path was used in R, but markdown could not knit it so the data was loaded as explained in step 3.
```{r eval = FALSE} 
root.dir = dirname(rstudioapi::getSourceEditorContext()$path)
data = readRDS(paste0(root.dir, "/DepMap19Q1_allData.RDS"))
```

## 3. Loading the data set
```{r}
data = readRDS("C:/Users/LeoTh/Documents/GitHub/project-01-group-02/DepMap19Q1_allData.RDS")
data$expression[1:10,1:5]
data$copynumber[1:10,1:5]
data$kd.ceres[1:10,1:5]
data$kd.prob[1:10,1:5]
data$annotation[1:10,1:5]
data$mutation$`ACH-000004`[1:10,1:5]

```


# <span style="color:orange">**Part 1: Data cleanup**</span>

## <span style="color:orange">**1.1 Extracting and splitting our data**</span>   
  
Defining a new matrix only containing the mutation data which is structured differently from the other matrices.  
```{r}
mut <- data$mutation 
```
  
Additionally, to the mutation matrix another matrix is needed containing all matrices except the mutation data.
```{r}
'%!in%' <- function(x,y)!('%in%'(x,y))  # defining an operator that will only pick the data that is NOT defined in the list; so the data that needs to be excluded
dt_new <- lapply(which(names(data) %!in% "mutation"), function(a) data[[a]]) # extracting the non-mutation data 
names(dt_new) <- names(data)[which(names(data) %!in% "mutation")] # renaming the data with the original names
#our data now consists out of 2 lists 
names(dt_new)
head(mut[[1]])#just picking one cell line as an example
```
The next step is to extract the cell lines of the skin cancer. For that we need to get to know the names of the cell lines from the skin cancer, this information we can get out of the annotation dataframe. Then we can create a new dataframe which only contains the data we will work with.

Defining which samples will be taken out of the original dataset.
```{r}
sample_case = c("Skin Cancer") 
``` 

Looking at the annotation matrix and searching only for the primary diseases matching the previous defined sample_case. 
A vector containing all the cell lines with skin cancer as the primary disease is obtained.
```{r}
samples = data$annotation$DepMap_ID[which(data$annotation$Primary.Disease == sample_case)]
```
34 cell lines have the primary disease skin cancer.

Extracting all cell lines defined in the previous step out of the data (except the mutation matrix).
```{r}
processed_data <- lapply(1:length(dt_new), function(a) { # picking the data for our sample 
  dat_picker <- dt_new[[a]] # picking one file at each iteration 
  if(names(dt_new[a])== "annotation"){ # treating the annotations differnetly because the cell line names are in a colum and are not the columnames like in the other matrices
    output <- dat_picker[which(dat_picker[,1] %in% samples),]
  } else {
  output <- dat_picker[,which(colnames(dat_picker) %in% samples)]# only taking the skin cancer cell lines 
  output <- output[complete.cases(output),] # only taking rows without NAs 
  output <- output[order(rownames(output)),] # reordering the genes according to their name
  }
  return(output)
})
names(processed_data) <- names(dt_new) # renameing the objects according to the original data
rm(dt_new,sample_case) # removing objects which are not need anymore
#taking a look at the data: 
processed_data$expression[1:10,1:5]
processed_data$copynumber[1:10,1:5]
processed_data$kd.ceres[1:10,1:5]
processed_data$kd.prob[1:10,1:5]
processed_data$annotation[1:10,1:5]
processed_data$mutation$`ACH-000004`[1:10,1:5]
```

Extracting the previously defined cell lines from the mutation data.
```{r}
ids = which(names(mut) %in% samples) 
allDepMap_mutation_SkinCancer = lapply(ids, function(a) {
  mut[[a]]})
rm(mut, ids, data) #tidying
```

Losing the mutations which are not deleterious meaning not interesting to us.
```{r}
allDepMap_mutation_SkinCancer = lapply(1:34, function(a) {
  allDepMap_mutation_SkinCancer[[a]][which(allDepMap_mutation_SkinCancer[[a]][,"isDeleterious"]== TRUE), ]
    })
names(allDepMap_mutation_SkinCancer) <- samples
```

Losing all genes which are not in every data frame. 
First, all gene names have to be picked out of the data.
```{r}
Genenames <- unique(c(rownames(processed_data[[1]]),rownames(processed_data[[2]]),rownames(processed_data[[3]]),rownames(processed_data[[4]])))
```

Then picking these genes which are in all 4 data frames which are needed for further analysis. 
```{r}
i <- 1
out <- vector("character", length(seq_along(1:16970)))# length of the matrix depending on how many Genes we have which are in every data frame
for (x in seq_along(Genenames)) {
  if(Genenames[x] %in% rownames(processed_data$expression) & Genenames[x] %in% rownames(processed_data$copynumber) & Genenames[x] %in% rownames(processed_data$kd.ceres) & Genenames[x] %in% rownames(processed_data$kd.prob))
  {out[i] <- Genenames[x]
  i <- i+1
  } 
}

allDepMap_annotation_SkinCancer <- processed_data$annotation # saving the annotation object in a seperate dataframe
# because it doesnt contain any information about the genes 

processed_data <- lapply(processed_data[1:4], function(a) {
  a <- a[which(rownames(a) %in% out),]
  return(a)
})

processed_data$mutation <- allDepMap_mutation_SkinCancer
processed_data$annotation <- allDepMap_annotation_SkinCancer
rm(i,out, Genenames,x, allDepMap_annotation_SkinCancer, samples, allDepMap_mutation_SkinCancer)

```

Looking at the processed data.
```{r}
processed_data$expression[1:10,1:5]
processed_data$copynumber[1:10,1:5]
processed_data$kd.ceres[1:10,1:5]
processed_data$kd.prob[1:10,1:5]
processed_data$annotation[1:10,1:5]
processed_data$mutation$`ACH-000004`[1:10,1:5]
```

# <span style="color:orange">**Part 2: Data visualisation**</span>  

## <span style="color:orange">**2.1 Preparing our data for plotting**</span>

### <span style="color:orange">**2.1.1 Extracting our data for plotting**</span>

Not all the data is needed for plotting so the data is prepared for the following plots.
```{r}
generalPlottingData <- lapply(1:(length(processed_data)-2), function(a) { # the annotation matrix is not needed
  dtPicker <- processed_data[[a]]
  out <- melt(dtPicker) # binding the data togehter that it has samples and values as columns
  out$Gene <- rep(rownames(dtPicker), ncol(dtPicker)) # adding the genes; probably this might be useful in a later stage
  out$Case <- names(processed_data)[1:(length(processed_data)-1)][a]# adding a labelling column
  colnames(out) <- c("Sample", "Value", "Gene", "Case") # renameing the columns
  return(out)
})
names(generalPlottingData) <- names(processed_data)[1:(length(processed_data)-2)] # renameing the data 
```


### <span style="color:orange">**2.1.2 Plotting Data - Driver Mutations**</span>

Producing a vector encompasing every gene which at least mutated once.
```{r}
singleGenes <- as.vector(unique(as.data.frame(rbindlist(lapply(seq_along(processed_data$mutation), function(a) {
  out <- as.data.frame(as.vector(unique(processed_data$mutation[[a]]$Hugo_Symbol)))}))))[,1])
```

Creating a data frame containing the mutation rate of every gene.
```{r}
geneCounts <- sapply(seq_along(singleGenes), function(a) {
  genePicker <- singleGenes[a] # picking one gene
  sumGene <- lapply(seq_along(processed_data$mutation), function(b) {
    mutPicker <- processed_data$mutation[[b]] # picking one of the 34 mutation lists
    out <- as.data.frame(length(which(mutPicker$Hugo_Symbol == genePicker))) # looking how often an entry is in the mutation list
    return(out)
  })
  geneCount <- colSums(as.data.frame(rbindlist(sumGene))) # summing it up to get the total count for each gene
  return(geneCount)
})
names(geneCounts) <- singleGenes # renameing 
geneCounts <- as.data.frame(geneCounts) # creating a nice data frame
colnames(geneCounts) <- c("Value")
geneCounts <- geneCounts[order(-geneCounts$Value), , drop = FALSE] # sorting the data frame
head(geneCounts) 
```

Extacting the data for the top 10 which will be our driver mutations in the further investigation.
```{r}
dataTopDriverGenes <- lapply(1:(length(processed_data)-2), function(a) { # picking the data for our sample 
  dat_picker <- processed_data[[a]] # picking one file at each iteration 
  output <- dat_picker[which(rownames(dat_picker) %in% rownames(geneCounts)[1:10]),] # comparing the rownames of the picked data with the names of the 10 most mutated genes
  return(output)
})
names(dataTopDriverGenes) <- names(processed_data)[1:4]

rm(singleGenes)
```


### <span style="color:orange">**2.1.3 Extracting the drivermutations for every cell line**</span>

Putting all mutation data in one matrix. 
```{r}
oneMatrix <- data.frame()
for (i in c(1:34)) { # 34 is the number of cell lines of interest
  oneMatrix <- rbind(oneMatrix,processed_data$mutation[[i]][,Hugo_Symbol:DepMap_ID])
}
```

Extracting just the column of the gene name and the cell line.
```{r}
celllinesMutations <- oneMatrix[which(oneMatrix$Hugo_Symbol %in% rownames(geneCounts)[1:10] ),]
celllinesMutations <- cbind(celllinesMutations$Hugo_Symbol, celllinesMutations$DepMap_ID)
View(celllinesMutations)
```

Extracting the drivermuations for every cell line out of the data frame and putting it into another data frame so it can be used for plotting.
```{r}
Genes <- c("COL11A1,TMTC2,TTN", " HMCN1", "COL11A1,HMCN1,SLC510", "HMCN1,TMTC2", "COL11A1,TP53,TTN","none","ZNF292","RYR2","HMCN" ,"none2","none3", "TP53, TTN","HMCN1", "TTN,ZNF292","TMTC2,TP53,NEB","TP53", "TMTC2,NEB","none4","TMTC2,TTN,ZNF292", "none5","CACNA1I","HMCN1,TP53,ZNF292","none6","none7","HMCN1,TMTC2,ZNF292","RYR2,TMTC2,NEB","RYR2,NEB,TTN,CACNA1I","HMCM1,TP53","TTN","COL11A1,SLC5A10","COL11A1,CACNA1I","TTN,CACNA1I","RYR2,CACNA1I,ZNF292","TP53,TTN,CACNA1I" )
celllines <- c(colnames(processed_data$expression))
cellinesMutations <- as.data.frame(cbind(celllines, Genes))

rm(oneMatrix, Genes,celllines,i)
```
The explanation for the previous extraction will be outlined in the following visualization part.


## <span style="color:orange">**2.2 Visualizing our data**</span>

### <span style="color:orange">**2.2.1 Heatmap with the knock down data**</span>

Starting with a heatmap of the knock down data (the kd.ceres matrix).
This matrix consists of gene knockdown scores. The impact of the knocked out gene on the cell survival is reflected by that score. The impact can be a reduction or an increase in proliferation. It could also mean that there is no change in cell proliferation at all. Smaller values refer to higher importance. Useing only the first 50 genes because otherwise the computer was overchallenged and could not produce the heatmap.
```{r}
pheatmap(as.matrix(processed_data$kd.ceres[1:50,]), clustering_method = "ward.D2",border_color = "white", fontsize = 8, 
         main = paste0("kdCERES for potential 2nd site targets"),
         show_rownames = F, show_colnames = T,
         cutree_rows = 4,
         cutree_cols = 2, 
         fontsize_row=8) 
```
   
   
***

> * *There are clear differences between the knockdown data depending on the knocked out gene in a specific cell line.*
> * *The cell lines behave differently when the same gene is knocked out.*
> * *This means there are genes that are important for cell proliferation and could play a role in cancer development.*

***

### <span style="color:orange">**2.2.2 Distribution of the expression values between the different cell lines**</span>

Creating a boxplot with the expression matrix to see how the expression of the genes is distributed over the different cell lines. 
```{r}
data <- generalPlottingData$expression

ggplot(data, aes(x=Sample, y= Value)) +
  geom_boxplot(aes(fill = Sample), outlier.size = 0.1, outlier.alpha = 0.2) + # reconstructing the outliers a bit (reduce them in size; because we are interested in the boxplots and not the outliers)
  theme_bw(base_size = 7) + # formating the size of the theme nicely
  theme(legend.position= "none", # defining the legend position (here no leghend will be needed)
        legend.direction="horizontal", #define the legend direction if one is there
        plot.title = element_text(hjust = 0.5), # making the title of the plot into the middle
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), # defining the orientation of the text on the x-axis
        legend.title= element_blank(), # no title of the legend should be plotted
        axis.title.x = element_blank(), # no title of the x-axis is relevant; because that would be samples and that is cleare due to the naming
        strip.text.y = element_text(angle = 90)) # defining the orientation of the text of the y-axis
```
   
   
***

> * *Many genes are distributed between the 25 and 75 quantile. But there are also some outliers which are of special interest in the following data analysis.*
> * *For now we can say that the data is differnetly distributed between the celllines based on different mutations in the different cell lines.*

***



### <span style="color:orange">**2.2.3 Top 10 mutated genes**</span>

In the Data extraction part we extracted the genecounts for every mutation. Firstly we want to take a general look at the distribution of the mutation number of every gene over all cell lines: 
```{r}
plotData <- geneCounts

plotData$Gene <- rownames(plotData)

ggplot(data = plotData) +
  (geom_bar(mapping = aes(x = Gene, y = Value), stat = "identity")) +
  theme_bw(base_size = 7) + # formating the size of the theme nicely
  theme(legend.position= "none", # defining the legend position (here no legend will be needed)
        legend.direction="horizontal", # defining the legend direction if one is there
        plot.title = element_text(hjust = 0.5), # making the title of the plot into the middle
        axis.text.x = element_blank(), # defining the orientation of the text on the x-axis
        axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10), # defining the orientation of the text on the x-axis
        legend.title= element_blank(), # no title of the legend should be plotted
        axis.title.x = element_blank(), # no title of the x-axis is relevant; because that would be samples and that is cleare due to the naming
        strip.text.y = element_text(angle = 90)) # defining the orientation of the text of the y-axis
rm(plotData)
```


Now we want to see which mutations are the top 10 mutated genes. 
```{r}
plotData <- geneCounts[1:10, ,drop = FALSE]

plotData$Gene <- rownames(plotData)

ggplot(data = plotData) +
  (geom_bar(mapping = aes(x = Gene, y = Value), stat = "identity")) +
  theme_bw(base_size = 7) + # formating the size of the theme nicely
  theme(legend.position= "none", # defining the legend position (here no legend will be needed)
        legend.direction="horizontal", # defining the legend direction if one is there
        plot.title = element_text(hjust = 0.5), # making the title of the plot into the middle
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10), # defining the orientation of the text on the x-axis
        axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10), # defining the orientation of the text on the x-axis
        legend.title= element_blank(), # no title of the legend should be plotted
        axis.title.x = element_blank(), # no title of the x-axis is relevant; because that would be samples and that is cleare due to the naming
        strip.text.y = element_text(angle = 90)) # defining the orientation of the text of the y-axis
rm(plotData)
```

***

> * *The expected driver mutations are BRAF, RAS, NF1 and Triple-WT, because they are specific for cutaneous melanoma (1).*
> * *The barplot does not mention any of the expected ones, so in the end an analysis of the biological background is needed.*

***

# <span style="color:orange">**3. Dimensionality reduction**</span>

General questions: 


> * Can we group the different driver mutations together so that we can see in which other genes the cell lines with a specific driver mutation differentiate?
> * With Dimnsionality reduction we could gain insight which other genes are our secound targets. 


## <span style="color:orange">**3.1 Hierachical clustering**</span>

Creating a hierachical cluster with our driver mutations.
```{r}
drivergene <- 3 
# determines which of the driver mutations will be seen in the cluster at the x axis
dataset <- processed_data$expression # determines which dataset we use

colnames(dataset)[which(colnames(dataset) %in% unique(celllinesMutations[which(celllinesMutations[,1] == rownames(geneCounts)[drivergene]),2]))] <- rownames(geneCounts)[drivergene] 
# setting the colnames of the cell lines which have the drivermutation entered in the dirvermutation variable , to this drivermutation so we can see if these cell lines cluster together
# drivermutation 3 is just an example can set every drivergene of interest


cor.mat = cor(dataset, method = "spearman")
cor.dist = as.dist(1 - cor.mat)
cor.hc = hclust(cor.dist, method = "ward.D2")
cor.hc = as.dendrogram(cor.hc)
plot(cor.hc, las = 2, cex.lab = 1, main = "Clustering of the expression values of all cell lines")

rm(drivergene, realcelllinenames, dataset, cor.hc, cor.mat, cor.dist)
```

## <span style="color:orange">**3.2 K-means**</span>

Performing a k-means to identify the structure of our clusters. 
```{r}
dataset <- t(processed_data$expression[-which(rownames(processed_data$expression) %in% rownames(geneCounts)[1:10]),]) 
# determining which dataset we use
# trying to cluster the cell lines with the same driver mutations in the same cluster according to the 
# expression data without the expression of the driver mutations
# Searching for the cause of the diffences between the cell lines besides the expression of the driver mutations 

rownames(dataset) <- cellinesMutations$Genes

dataset <- dataset[,-which(apply(dataset, 2, function(x) {
  var(x)
}) == 0)]
```

For choosing the best number centers for the clusters the kink method was used.
```{r}
wss = sapply(1:9, function(k) {
  kmeans(x = dataset, centers = k)$tot.withinss
})
plot(1:9, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares")
```

***

> * *But theres no kink in this curve so we need to use other methods to tell us how much centers would be best to choose.*

***

Now we try the silouette method.
```{r}
fviz_nbclust(dataset, kmeans, method = "silhouette")
# according to the silhouette method the clustering with two centers seems to be the best one

# taking a look at the clustering with different centers (2, 4, 5, 10) 
km = kmeans(x =dataset, centers = 2, nstart = 100)
plot(silhouette(km$cluster,dist(dataset)), main = "Silhouette Values for 2 clusters", cex=0.5)

km2 <- kmeans(dataset, centers = 2, nstart = 100)
km3 <- kmeans(dataset, centers = 5, nstart = 100)
km4 <- kmeans(dataset, centers = 4, nstart = 100)
km5 <- kmeans(dataset, centers = 10, nstart = 100)



p1 <- fviz_cluster(km2,geom = "point", data = dataset) + ggtitle("k = 2")
p2 <- fviz_cluster(km3, geom = "point", data = dataset) + ggtitle("k = 5")
p3 <- fviz_cluster(km4, geom = "point", data = dataset) + ggtitle("k = 4")
p4 <- fviz_cluster(km5, geom = "point", data = dataset) + ggtitle("k = 10")

grid.arrange(p1, p2, p3, p4, nrow = 2)

p4 <- fviz_cluster(km5, geom = "text", labelsize = 9, data = dataset) + ggtitle("k = 10")
plot(p4) # clustering with 10 centers does not conclude in clusters with the same driver mutations
# having more than one driver mutation in most cell lines may cause this
p1 <- fviz_cluster(km2,geom = "text", labelsize = 9, data = dataset) + ggtitle("k = 2")
plot(p1) 

rm(km,km2,km3,km4,km5,p1,p2,p3,p4, dataset,wss)
```

***

> * *The clustering with two centers seems to be the best one.*
> * *Our next step in the pca will be to see which of the genes drive the differentation of the celllines in this plot because they will be the most variable and thus most interesting ones.*

***

# <span style="color:orange">**3.3 PCA**</span>

Investigating with a principal component analysis why the data clusters together the way it does. Looking at the first two principal components because they are the most interesting. 
```{r}

dataset <- processed_data$expression # determining which dataset will be used

colnames(dataset)<- cellinesMutations$Genes

pca = prcomp(t(dataset), center = F, scale. = F)
summary(pca)
# showing labels (cell lines)


fviz_eig(pca)
str(pca)
autoplot(pca, colour = 'blue')
fviz_pca_ind(pca,
             col.ind = "cos2", # color by the quality of representation
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE,     # Avoid text overlapping
)
```

***

> * *Again, there are two clusters.*
> * *The first principal component contains the most information about the data.*

***


```{r}
var_coord_func <- function(loadings, comp.sdev){
  loadings*comp.sdev
}

loadings <- pca$rotation
sdev <- pca$sdev
var.coord <- t(apply(loadings, 1, var_coord_func, sdev)) 

var.cos2 <- var.coord^2
comp.cos2 <- apply(var.cos2, 2, sum)
contrib <- function(var.cos2, comp.cos2){var.cos2*100/comp.cos2}

var.contrib <- t(apply(var.cos2,1, contrib, comp.cos2))
head(var.contrib[, 1:4])
top100var.contrib <- var.contrib[,1]
top100var.contrib <- as.data.frame(top100var.contrib[order(-top100var.contrib)])
top100var.contrib$Genes <- rownames(top100var.contrib)
top100var.contrib <- top100var.contrib[1:100,]
colnames(top100var.contrib)[1] <- "Contribution"


ggplot(data = top100var.contrib) +
  (geom_bar(mapping = aes(x = Genes, y = Contribution), stat = "identity")) +
  theme_bw(base_size = 7) + # formating the size of the theme nicely
  theme(legend.position= "none", # defining the legend position (here no leghend will be needed)
        legend.direction="horizontal", # defining the legend direction if one is there
        plot.title = element_text(hjust = 0.5), # making the title of the plot into the middle
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 5), # defining the orientation of the text on the x-axis
        axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10), # defining the orientation of the text on the y-axis
        legend.title= element_blank(), # no title of the legend should be plotted
        axis.title.x = element_blank(), # no title of the x-axis is relevant; because that would be samples and that is cleare due to the naming
        strip.text.y = element_text(angle = 90)) # defining the orientation of the text of the y-axis
```

***

> * *These are the components which are contributing the most to our variation in the data. Maybe we will find some of these in our result of the p-test.*

*** 

```{r}
rm(drivergene, realcelllinenames, dataset, loadings, pca, realcelllinenames, var.contrib, var.coord, var.cos2, comp.cos2, sdev)
```   


# <span style="color:orange">**4. Statistical test**</span>

We want to perform a p-test and compare the p-values. 
```{r}
driverGenes <- rownames(geneCounts)[1:10] # only using the TOP 10 driver genes
ttestgenes <- rownames(processed_data$kd.ceres)

potSecondSites <- lapply(seq_along(driverGenes), function(a) {
  genePicker <- driverGenes[a] # picking one driver gene
  print(paste0("I am doing driver mut: ", a))
  output <- sapply(seq_along(rownames(processed_data$kd.ceres)), function(b) { #the kdCERES matrix is of interest take its' rownames as refrence
    secondSitePicker <- rownames(processed_data$kd.ceres)[b] # picking a potetnial 2nd site target
    if (secondSitePicker != genePicker) {
      drMUT <- processed_data$kd.ceres[which(rownames(processed_data$kd.ceres) == genePicker),] # picking the driver mut data
      sndMUT <- as.vector(processed_data$kd.ceres[which(rownames(processed_data$kd.ceres) == secondSitePicker),]) # picking the 2nd site data
      cor.val <- cor.test(unlist(drMUT, use.names=FALSE) , unlist(sndMUT, use.names=FALSE), method = "spearman") # making a spearman correlation
      return(cor.val$p.value) # returning the p-values
    } else {
      return(1)
    }
  })
  names(output) <- rownames(processed_data$kd.ceres) # renaming all
  output <- as.data.frame(output) # getting a nice data frame
  return(output)
})
names(potSecondSites) <- driverGenes # renaming the list of lists
lapply(potSecondSites, head) # looking at the nice data
```

Now that we got all those p-values we want to order the data according to their p-values. So we can see the smallest ones which are the most important ones. 
```{r}
potSecondSites <- lapply(potSecondSites, function(a){
  a <- as.data.frame(cbind(a$output, rownames(a)))
  a <- a[order(a[1]), ]
})
```

Selecting the 20 genes out of every DriverGene List with the lowest p score.
```{r}
potSecondSitestop20 <- lapply(seq_along(potSecondSites), function (a){
  output <- potSecondSites[[a]][1:20,]
  return(output)
})
names(potSecondSitestop20) <- driverGenes

ggplot(data = potSecondSitestop20$TTN) +
  (geom_bar(mapping = aes(x = V2, y = V1), stat = "identity")) +
  theme_bw(base_size = 7) + # formating the size of the theme nicely
  theme(legend.position= "none", # defining the legend position (here no legend will be needed)
        legend.direction="horizontal", # defining the legend direction if one is there
        plot.title = element_text(hjust = 0.5), # making the title of the plot into the middle
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 10), # defining the orientation of the text on the x-axis
        axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=1, size = 8), # defining the orientation of the text on the y-axis
        legend.title= element_blank(), # no title of the legend should be plotted
        axis.title.x = element_blank(), # no title of the x-axis is relevant; because that would be samples and that is cleare due to the naming
        strip.text.y = element_text(angle = 90)) # defining the orientation of the text of the y-axis

rm(potSecondSites, ttestgenes)
```

# <span style="color:orange">**5. Multiple linear regression analysis**</span>

## <span style="color:orange">**5.1 Predicting the expression of our driver genes with all the data**</span>

Creating a data frame for the multiple linear regression. In this data frame all the columns are the data frames and the rows represent the genes in every cell line.

With this data frame the linear regression is performed. After that the predicted values are compared with the real values of the data_set by a spearman correlation. Performing this with every driver gene.
```{r}
# Building the dataframe for the linear Regression
a <- generalPlottingData$expression[,1:3]
a <-a[,c(1,3,2)]
copynumber <- generalPlottingData$copynumber[,2]
kd.ceres <- generalPlottingData$kd.ceres[,2]
kd.prob <- generalPlottingData$kd.prob[,2]

RegData <- cbind(a,copynumber,kd.ceres,kd.prob)

# doing the multiple linear regression 
# comparing the predicted values of our model with the real values of the test_data by spearman correlaton
# doing this for every driver gene

Regressionanalysis <-lapply(1:10, function(x){
  RegData <- cbind(a,copynumber,kd.ceres,kd.prob)
  Driverexpression <- c()
  for (i in 1:34) { # 34 = te skin cancer cell lines
    a <- 16970*i # 16970 = number of genes
    c <- (16970* (i-1))+1
    b <- colnames(processed_data$expression)[i]
    Driverexpression[c:a] <- processed_data$expression[rownames(geneCounts)[x],b]
  }
  print(paste0("I am doing driver mut: ", rownames(geneCounts)[x]))
  RegData <- cbind(RegData,Driverexpression)
  RegData <-as.data.frame(RegData)
  colnames(RegData) <- as.vector(colnames(RegData))
  set.seed(123) # initializing the random numbers
  split = sample.split(RegData, SplitRatio = 0.8) # splitting the dataset into 4/5 Training and 1/5 Testing dataset
  training_set = subset(RegData, split == TRUE) # using the labels to get the training data
  test_set = subset(RegData, split == FALSE) 
  rm(RegData)
  # fitting the multiple linear regression to the Training set
  regressor = lm(Driverexpression ~ Value + copynumber + kd.ceres + kd.prob , data = training_set) # predicting profit based on ALL (=.) the input variables for one company 
  # predicting the test set results
  y_pred = predict(regressor, newdata = test_set, se.fit = TRUE) # predicting the expression based on the testing data 
  test_set$Prediction = y_pred$fit # adding the predictions to the dataset
  # comparing the predictions (last column) with the real values of the startups (2nd last column)
  Results <- cor.test(test_set$Driverexpression, test_set$Prediction, method = "spearman", exact=FALSE)
  return(Results)
})
names(Regressionanalysis) <- rownames(geneCounts)[1:10]
Regressionanalysis <- as.vector(Regressionanalysis)
rm(RegData,kd.ceres,kd.prob,copynumber,a)


ResultsRegression <- melt(lapply(1:length(Regressionanalysis), function(x){
  return(Regressionanalysis[[x]][3])
}))
ResultsRegression <- cbind(ResultsRegression,melt(lapply(1:length(Regressionanalysis), function(x){
  return(Regressionanalysis[[x]][1])
})))

ResultsRegression$L2 <- rownames(geneCounts)[1:10]
ResultsRegression <- ResultsRegression [,c(2,1,4)]
colnames(ResultsRegression) <- c("DriverGene", "pvalue", "Svalue" )

print(ResultsRegression)


```

***

> * *With these low p-values we can say with confidence that our Model is able to reproduce and predict the expression values of our driver genes.*
> * *Using just our top 20 out of the statistical testing we hoped to see that the p values would not increase that much. This would verify our these that these genes are the essential components which drive the different expression of the Driver Gene.*
> * * As you can see below this ist not the case and the p values are very much increased.*

***

```{r}
Regressionanalysistop20 <-lapply(1:10, function(x){
  a <- generalPlottingData$expression[which(generalPlottingData$expression[,3] %in% as.character(potSecondSitestop20[[x]][,2])),1:3]
  a <-a[,c(1,3,2)]
  copynumber <- generalPlottingData$copynumber[which(generalPlottingData$copynumber[,3] %in% as.character(potSecondSitestop20[[x]][,2])),2]
  kd.ceres <- generalPlottingData$kd.ceres[which(generalPlottingData$kd.ceres[,3] %in% as.character(potSecondSitestop20[[x]][,2])),2]
  kd.prob <- generalPlottingData$kd.prob[which(generalPlottingData$kd.prob[,3] %in% as.character(potSecondSitestop20[[x]][,2])),2]
  RegData <- cbind(a,copynumber,kd.ceres,kd.prob)
  h <- length(generalPlottingData$expression[which(generalPlottingData$copynumber[,3] %in% as.character(potSecondSitestop20[[x]][,2])),2])
  Driverexpression <- c()
  for (i in 1:34) {
    a <- h*i
    c <- (h* (i-1))+1
    b <- colnames(processed_data$expression)[i]
    Driverexpression[c:a] <- processed_data$expression[rownames(geneCounts)[x],b]
  }
  print(paste0("I am doing driver mut: ", rownames(geneCounts)[x]))
  RegData <- cbind(RegData,Driverexpression)
  RegData <-as.data.frame(RegData)
  colnames(RegData) <- as.vector(colnames(RegData))
  set.seed(123) #initialize the random numbers
  split = sample.split(RegData, SplitRatio = 0.8) #split the dataset into 4/5 Training and 1/5 Testing dataset
  training_set = subset(RegData, split == TRUE) #use the labels to get the training data
  test_set = subset(RegData, split == FALSE) 
  rm(RegData)
  # Fitting Multiple Linear Regression to the Training set
  regressor = lm(Driverexpression ~ Value + copynumber + kd.ceres + kd.prob , data = training_set) #predict profit based on ALL (=.) the input variables for one company 
  # Predicting the Test set results
  y_pred = predict(regressor, newdata = test_set, se.fit = TRUE) #predict the expression based on your testing data 
  test_set$Prediction = y_pred$fit #add your predictions to the dataset
  #Now compare the Predictions (last column) with the real values of the startups (2nd last column)
  Results <- cor.test(test_set$Driverexpression, test_set$Prediction, method = "spearman", exact=FALSE)
  return(Results)
})
names(Regressionanalysistop20) <- rownames(geneCounts)[1:10]
Regressionanalysistop20 <- as.vector(Regressionanalysistop20)

ResultsRegressiontop20 <- melt(lapply(1:length(Regressionanalysistop20), function(x){
  return(Regressionanalysistop20[[x]][3])
}))
ResultsRegressiontop20 <- cbind(ResultsRegressiontop20,melt(lapply(1:length(Regressionanalysistop20), function(x){
  return(Regressionanalysistop20[[x]][1])
})))

ResultsRegressiontop20$L2 <- rownames(geneCounts)[1:10]
ResultsRegressiontop20 <- ResultsRegressiontop20 [,c(2,1,4)]
colnames(ResultsRegressiontop20) <- c("DriverGene", "pvalue", "Svalue" )

print(ResultsRegressiontop20)
```


***
> * * With this result we can not define confidently the second targets.*

*** 

# <span style="color:orange">**6.Results**</span>

```{r}
Resultspresentation <- lapply(1:length(potSecondSitestop20), function(x){
  return(potSecondSitestop20[[x]][2])
})

names(Resultspresentation) <- rownames(geneCounts)[1:10]
print(Resultspresentation)

print(top100var.contrib[1:20,2])

which(top100var.contrib[1:20,2] %in% as.character(melt(Resultspresentation)[,1]))

```

***

> * *Our top 10 driver mutations are : TTN, TP53, HMCN1, TMTC2, RYR2,  CACNA1I, ZNF292, NEB, COL11A1, SLC5A10. We defined them with a barplot at the beginning.*
> * *Our goal was to find possible second side targets interacting with these driver mutations more often than other mutations and which are of a greater importance than other interactin genes.* 
> * *We tried to define these targets with a PCA and a p-test.But the 2nd targets from the pca and the regression are not overlapping. This could be due to the data or mistakes we made in the skript. Also the kmeans and the PCA do not reproduce the same second side targets.*
> * *However we decided to present the targets we defined with the p-test. As shown above we have listed the top 20 second side targets from the p-test for each gene.* 
> * *The regression model shows a really low p-value at which leads us to the conclucion that the above listed genes could be taken in account as targets for drug development in skin cancer.*

***

# <span style="color:orange">**7. Biological background**</span>

Firstly, the literature identifies BRAF, RAS, NFI and Triple WT as the
leading mutations for skin cancer (1). Unfortunatly, mutations of these
genes are not emphasized as our top 10 driver mutations.  

However, we will now take a look at our results. Could the driver mutation
extracted from our data be related to skin cancer? And are there biological
interactions between the driver mutations and the second targets?  

In the following, we will be investigating our top mutated genes TTN,
TP53 and their second targets and their relevence in skin cancer therapy.  

TTN, which is our top mutated gene, encodes for the largest protein in the
human genome and is a part of the sacromere in the steriated muscle (2).
Its complex structure and size, which leads to the sacromeric organization
during a contraction, is due to its composition of 364 exons (2). That creats a protein, which is approximatly composed of 38,000 amino acid residues(2). The mentioned sacromere gene is stated to be a major human disease gene, for instance, truncating types of TTN are reprotedly the main reason for dilated cardiomyopathy, which is a common cause of heart failure and cardiac death (2).  

Tissue expression of TTN in heart muscle and skeletal muscle (3):

![](C:/Users/LeoTh/Documents/GitHub/project-01-group-02/Bioinfobilder/proteinexpressionofTTN.png)

It is possible to see in the chart, that TTN is not detected in skin tissue, consequently, it will not play a leading role in the developement of skin cancer. Nevertheless, in the following we will investigate in how well our analysis was able to predict possible second targets.  

In that matter we used a website called GeneMANIA, which is a server for
biological network integration and predicting gene functions (4). The
website enables us to visually see how genes are connected and to what
extend physical interactions, co-expression, co-localiation, pathway,
genetic interactions and shared protein domains can be found (4). It is
possible to download a full report to gain fruther inside, for instance,
which pathway in particular is connecting these genes (4).
In our results the three major second targets for TTN are C18orf21, NFIC,
TADA2A. Our driver mutation and the calculated second targets are
indicated with stripes.  

Network of TTN and second targets:  

![](C:/Users/LeoTh/Documents/GitHub/project-01-group-02/Bioinfobilder/genemanianetwork2.jpg)


![](C:/Users/LeoTh/Documents/GitHub/project-01-group-02/Bioinfobilder/legende.png)



In the report it is stated that 67,64% of physical interaction and 13,5% of co-expression can be found, whereas, the probabilty for shared pathways and genetic interactions are significantyl low (4). Physical interaction indicates that these proteins are likely to form bonds between complexes and interact with each other (5). TTN is not directly connected with any second target, however, a link is to be found between TTN and NFIC which are co-expressed with NEB (nebulin),which is giant protein component of the cytoskeletal matrix that coexists with the thick and thin filaments within the sarcomeres of skeletal muscle (6).  

As we mentioned in our results, because of our regression analysis it is not possible to state C18orf21, NFIC, TADA2A confidently as second targets,
thus, the computed network propably does not match the underlying interactions in our data set.  

In the following we will take a look at TP53, which is our second most
mutated gene, and its second targets. This gene is a tumor suppressor
protein containing transcriptional activation, DNA binding, and
oligomerization domains, additionally, it plays a major role in the
induction of cell cycle arrest, apoptosis, senescence, DNA repair, and
changes in metabolism (7). A loss of function in TP53 through a mutation
can lead to multiple types of human cancer (7). UV irridation appears to
play a significant role in the mutation of TP53, according to the article
" p53 and the Pathogenesis of Skin Cancer" a significant number of TP53
mutants are to be found on sun-exposed skin (8). As a result, our second
targets for TP53 could be a lead for possible new drug targets in skin
cancer therapy.  

The top three second targets for TP53 ,which were extracted from our data
base, are CDKN1A, RAD50, TAF4. We perform an anlysis with
GeneMANIA to detect possible interactions (4). On the left side is our
driver mutation and second targets and on the right side are all possible
interaction partners are listed.

Network of TP53 and its second targets:

![](C:/Users/LeoTh/Documents/GitHub/project-01-group-02/Bioinfobilder/tp.jpg)

In this case its is noticeable that the correlation between the pathways of
TP53 and the second targets is significantly high with 4.35% , which is
illustrated below.

Network of pathways: TP53 and second targets:

![](C:/Users/LeoTh/Documents/GitHub/project-01-group-02/Bioinfobilder/pathwaycircle.jpg)

According to our analysis, CDKN1A is predicted most likely to be a
second target for TP53. Due to the correlation of driver mutation and the
second targets pathways ,we will take a fruther look into a possible link
between CDKN1A and TP53. CDKN1A is a cyclin dependent kinase
inhibitor and expresses proteins which function as regulators of cell cycle
progression at G1 (7). The expression of CDKN1A is controlled by TP53,
which means that CDKN1A has a key role in the p53-dependent cell cycle
G1 phase arrest caused by stress stimuli (7). It is reported that this second
target can interact with proliferating cell nuclear antigen and has a
regulatory role in S phase DNA repilcation and DNA damage repair (7).
G1/S checkpoint defects are mentioned to be significant factors in
melanoma tumorgenesis, although, the results implicate that cyclindependent
kinases and TP53 are not major drivers, but can be taken into
consideration (9).


To sum it up, in spite of the fact that the driver mutation from the literature and the calculated driver mutation from our data set do not match up, we were able to detect possible second targets for our driver mutations. In the case of TP53, CDKN1A gene has clearly biological interactions with TP53 and our mathematical model was able to predict this interaction.

# <span style="color:orange">**8. References**</span>

(1) Akbani et al. (2015), Genomic Classification of Cutaneous Melanoma. Cell 161, 1681-1696  
(2) Gigli M, Begay RL, Morea G, et al. A Review of the Giant Protein Titin
in Clinical Molecular Diagnostics of Cardiomyopathies. Front Cardiovasc
Med. 2016;3:21. Published 2016 Jul 21. doi:10.3389/fcvm.2016.00021  
(3) Uhlén M et al, 2015. Tissue-based map of the human
proteome. Science PubMed: 25613900 DOI: 10.1126/science.1260419,
Human Protein Atlas  
(4) Warde-Farley D, Donaldson SL, Comes O, Zuberi K, Badrawi R, Chao P, Franz M, Grouios C,
Kazi F, Lopes CT, Maitland A, Mostafavi S, Montojo J, Shao Q, Wright G, Bader GD, Morris Q
Nucleic Acids Res. 2010 Jul 1;38 Suppl:W214-20 PubMed Abstract  
(5) Clancy T, Rødland EA, Nygard S, Hovig E. Predicting physical interactions between
protein complexes. Mol Cell Proteomics. 2013;12(6):1723-1734. doi:10.1074/
mcp.O112.019828  
(6) Pruitt KD, Tatusova T, Brown GR, Maglott DR. NCBI Reference Sequences (RefSeq):
current status, new features and genome annotation policy. Nucleic Acids Res.
2012;40(Database issue):D130-D135. doi:10.1093/nar/gkr1079  
(7) O'Leary NA, Wright MW, Brister JR, Ciufo S, Haddad D, McVeigh R, Rajput B, Robbertse
B, Smith-White B, Ako-Adjei D, Astashyn A, Badretdin A, Bao Y, Blinkova O, Brover V,
Chetvernin V, Choi J, Cox E, Ermolaeva O, Farrell CM, Goldfarb T, Gupta T, Haft D, Hatcher
E, Hlavina W, Joardar VS, Kodali VK, Li W, Maglott D, Masterson P, McGarvey KM, Murphy
MR, O'Neill K, Pujar S, Rangwala SH, Rausch D, Riddick LD, Schoch C, Shkeda A, Storz SS,
Sun H, Thibaud-Nissen F, Tolstoy I, Tully RE, Vatsan AR, Wallin C, Webb D, Wu W,
Landrum MJ, Kimchi A, Tatusova T, DiCuccio M, Kitts P, Murphy TD, Pruitt KD. Reference
sequence (RefSeq) database at NCBI: current status, taxonomic expansion, and functional
annotation.
Nucleic Acids Res. 2016 Jan 4;44(D1):D733-45 PubMed
Tatusova T, DiCuccio M, Badretdin A, Chetvernin V, Nawrocki EP, Zaslavsky L, Lomsadze
A, Pruitt KD, Borodovsky M, Ostell J. NCBI prokaryotic genome annotation pipeline.
Nucleic Acids Res. 2016 Aug 19;44(14):6614-24 PubMed
Brister JR, Ako-Adjei D, Bao Y, Blinkova O. NCBI viral genomes resource. Nucleic Acids
Res. 2015 Jan;43(Database issue):D571-7 PubMed  
(8) Benjamin CL, Ananthaswamy HN. p53 and the pathogenesis of skin cancer. Toxicol
Appl Pharmacol. 2007;224(3):241-248. doi:10.1016/j.taap.2006.12.006  
(9) Soto JL, Cabrera CM, Serrano S, López-Nevot MA. Mutation analysis of genes that
control the G1/S cell cycle in melanoma: TP53, CDKN1A, CDKN2A, and CDKN2B.
BMC Cancer. 2005;5:36. Published 2005 Apr 8. doi:10.1186/1471-2407-5-36


# <span style="color:orange">**finally done :)**</span>
